<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Pranath Fernando">
<meta name="dcterms.date" content="2023-11-06">
<meta name="description" content="Structured data extraction is increasingly becoming an essential tool for developers who wish to harness the power of OpenAI’s capabilities. This blog post aims to provide an understanding of how developers use OpenAI functions for tagging and extraction - two primary use cases central to transforming unstructured text into structured, actionable data.">

<title>LivingDataLab - Enhancing Data Structuring through Tagging and Extraction with OpenAI and LangChain</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../images/favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

<script type="text/javascript">

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-91568149-1', 'auto');

ga('send', {
  hitType: 'pageview',
  'anonymizeIp': true,
});
</script>


<link rel="stylesheet" href="../css/styles.css">
<meta property="og:title" content="LivingDataLab - Enhancing Data Structuring through Tagging and Extraction with OpenAI and LangChain">
<meta property="og:description" content="Structured data extraction is increasingly becoming an essential tool for developers who wish to harness the power of OpenAI’s capabilities. This blog post aims to provide an understanding of how developers use OpenAI functions for tagging and extraction - two primary use cases central to transforming unstructured text into structured, actionable data.">
<meta property="og:image" content="https://github.com/pranath/blog/raw/master/images/langchain3.jpg">
<meta property="og:site-name" content="LivingDataLab">
<meta name="twitter:title" content="LivingDataLab - Enhancing Data Structuring through Tagging and Extraction with OpenAI and LangChain">
<meta name="twitter:description" content="Structured data extraction is increasingly becoming an essential tool for developers who wish to harness the power of OpenAI’s capabilities. This blog post aims to provide an understanding of how developers use OpenAI functions for tagging and extraction - two primary use cases central to transforming unstructured text into structured, actionable data.">
<meta name="twitter:image" content="https://github.com/pranath/blog/raw/master/images/langchain3.jpg">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">LivingDataLab</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../projects.html" rel="" target="" aria-current="page">
 <span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/pranath-fernando/" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/LivingDataLab" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/pranath" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Enhancing Data Structuring through Tagging and Extraction with OpenAI and LangChain</li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Enhancing Data Structuring through Tagging and Extraction with OpenAI and LangChain</h1>
                  <div>
        <div class="description">
          Structured data extraction is increasingly becoming an essential tool for developers who wish to harness the power of OpenAI’s capabilities. This blog post aims to provide an understanding of how developers use OpenAI functions for tagging and extraction - two primary use cases central to transforming unstructured text into structured, actionable data.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">natural-language-processing</div>
                <div class="quarto-category">langchain</div>
                <div class="quarto-category">openai</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Pranath Fernando </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 6, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../projects.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Projects Overview</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Projects</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../projects/doc-chat.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Document Chat</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../projects/doc-summarisation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Document Summarisation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../projects/web-page-chat.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Web Page Chat</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../projects/web-page-summarisation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Web Page Summarisation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../projects/youtube-chat.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">YouTube Chat</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../projects/youtube-summarisation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">YouTube Summarisation</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar"><div class="quarto-margin-header"><div class="margin-header-item">
<!-- Begin Mailchimp Signup Form -->
<link href="//cdn-images.mailchimp.com/embedcode/classic-071822.css" rel="stylesheet" type="text/css">
<style type="text/css">
    #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }
    /* Add your own Mailchimp form style overrides in your site stylesheet or in this style block.
       We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */
</style>
<div id="mc_embed_signup">
    <form action="https://livingdatalab.us8.list-manage.com/subscribe/post?u=e2d57b0d6e43b4f6bff927a55&amp;id=a30bdff125&amp;f_id=009d05e0f0" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
        <div id="mc_embed_signup_scroll">
        <h2>Subscribe</h2>
<div class="mc-field-group">
    <label for="mce-EMAIL">Email Address
</label>
    <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" required="">
    <span id="mce-EMAIL-HELPERTEXT" class="helper_text"></span>
</div>
    <div id="mce-responses" class="clear foot">
        <div class="response" id="mce-error-response" style="display:none"></div>
        <div class="response" id="mce-success-response" style="display:none"></div>
    </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_e2d57b0d6e43b4f6bff927a55_a30bdff125" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot">
                <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button">
            </div>
        </div>
    </div>
</form>
</div>
<script type="text/javascript" src="//s3.amazonaws.com/downloads.mailchimp.com/js/mc-validate.js"></script><script type="text/javascript">(function($) {window.fnames = new Array(); window.ftypes = new Array();fnames[0]='EMAIL';ftypes[0]='email';fnames[1]='FNAME';ftypes[1]='text';fnames[2]='LNAME';ftypes[2]='text';fnames[3]='ADDRESS';ftypes[3]='address';fnames[4]='PHONE';ftypes[4]='phone';fnames[5]='BIRTHDAY';ftypes[5]='birthday';}(jQuery));var $mcj = jQuery.noConflict(true);</script>
<!--End mc_embed_signup-->

</div></div>
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#understanding-tagging" id="toc-understanding-tagging" class="nav-link" data-scroll-target="#understanding-tagging"><span class="header-section-number">2</span> Understanding Tagging</a>
  <ul class="collapse">
  <li><a href="#the-concept-of-tagging" id="toc-the-concept-of-tagging" class="nav-link" data-scroll-target="#the-concept-of-tagging"><span class="header-section-number">2.1</span> The Concept of Tagging</a></li>
  <li><a href="#practical-example-of-tagging" id="toc-practical-example-of-tagging" class="nav-link" data-scroll-target="#practical-example-of-tagging"><span class="header-section-number">2.2</span> Practical Example of Tagging</a></li>
  </ul></li>
  <li><a href="#the-process-of-extraction" id="toc-the-process-of-extraction" class="nav-link" data-scroll-target="#the-process-of-extraction"><span class="header-section-number">3</span> The Process of Extraction</a>
  <ul class="collapse">
  <li><a href="#distinguishing-extraction-from-tagging" id="toc-distinguishing-extraction-from-tagging" class="nav-link" data-scroll-target="#distinguishing-extraction-from-tagging"><span class="header-section-number">3.1</span> Distinguishing Extraction from Tagging</a></li>
  <li><a href="#implementing-extraction-in-code" id="toc-implementing-extraction-in-code" class="nav-link" data-scroll-target="#implementing-extraction-in-code"><span class="header-section-number">3.2</span> Implementing Extraction in Code</a></li>
  </ul></li>
  <li><a href="#tagging-and-extraction-in-practice" id="toc-tagging-and-extraction-in-practice" class="nav-link" data-scroll-target="#tagging-and-extraction-in-practice"><span class="header-section-number">4</span> Tagging and Extraction in Practice</a>
  <ul class="collapse">
  <li><a href="#creating-a-tagging-model" id="toc-creating-a-tagging-model" class="nav-link" data-scroll-target="#creating-a-tagging-model"><span class="header-section-number">4.1</span> Creating a Tagging Model</a></li>
  </ul></li>
  <li><a href="#improving-output-with-helper-parsers" id="toc-improving-output-with-helper-parsers" class="nav-link" data-scroll-target="#improving-output-with-helper-parsers"><span class="header-section-number">5</span> Improving Output with Helper Parsers</a>
  <ul class="collapse">
  <li><a href="#extracting-information" id="toc-extracting-information" class="nav-link" data-scroll-target="#extracting-information"><span class="header-section-number">5.1</span> Extracting Information</a></li>
  <li><a href="#streamlining-the-extraction-process" id="toc-streamlining-the-extraction-process" class="nav-link" data-scroll-target="#streamlining-the-extraction-process"><span class="header-section-number">5.2</span> Streamlining the Extraction Process</a></li>
  </ul></li>
  <li><a href="#applying-tagging-and-extraction-to-real-world-data" id="toc-applying-tagging-and-extraction-to-real-world-data" class="nav-link" data-scroll-target="#applying-tagging-and-extraction-to-real-world-data"><span class="header-section-number">6</span> Applying Tagging and Extraction to Real-World Data</a>
  <ul class="collapse">
  <li><a href="#loading-and-analyzing-an-article" id="toc-loading-and-analyzing-an-article" class="nav-link" data-scroll-target="#loading-and-analyzing-an-article"><span class="header-section-number">6.1</span> Loading and Analyzing an Article</a></li>
  <li><a href="#extracting-information-from-large-texts" id="toc-extracting-information-from-large-texts" class="nav-link" data-scroll-target="#extracting-information-from-large-texts"><span class="header-section-number">6.2</span> Extracting Information from Large Texts</a></li>
  </ul></li>
  <li><a href="#conclusion-the-power-of-structured-data-extraction" id="toc-conclusion-the-power-of-structured-data-extraction" class="nav-link" data-scroll-target="#conclusion-the-power-of-structured-data-extraction"><span class="header-section-number">7</span> Conclusion: The Power of Structured Data Extraction</a></li>
  <li><a href="#acknowledgements" id="toc-acknowledgements" class="nav-link" data-scroll-target="#acknowledgements"><span class="header-section-number">8</span> Acknowledgements</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">1</span> Introduction</h2>
<p>Structured data extraction is increasingly becoming an essential tool for developers who wish to harness the power of Large Language Model capabilities. This blog post aims to provide a comprehensive understanding of how developers can use OpenAI functions for tagging and extraction, two primary use cases central to transforming unstructured text into structured, actionable data.</p>
</section>
<section id="understanding-tagging" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="understanding-tagging"><span class="header-section-number">2</span> Understanding Tagging</h2>
<section id="the-concept-of-tagging" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="the-concept-of-tagging"><span class="header-section-number">2.1</span> The Concept of Tagging</h3>
<p>Tagging involves submitting unstructured text to an OpenAI language model along with structured instructions. The language model then generates a structured output, creating a response that aligns with the provided description. This output typically contains tags corresponding to the sentiment and language of the input text.</p>
<p><img src="https://github.com/pranath/blog/raw/master/images/tag-extract-1.png" width="800"></p>
<p>So, in this example, we know that we want to generate an object that has the text’s emotion as well as a tag for the language that we pass in. So, when we bring in an implicit text, we’ll pass in a structured description that says “extract some sentiment, extract some language,” and the LLM will reason over that text and return an object with sentiment and language tags. This is comparable to, but slightly distinct from, the second use case, extraction.</p>
</section>
<section id="practical-example-of-tagging" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="practical-example-of-tagging"><span class="header-section-number">2.2</span> Practical Example of Tagging</h3>
<p>For instance, if we want to determine the sentiment of a text and its language, we structure a request that specifies these requirements. The model processes the text and returns an object tagged with both sentiment and language. This allows for a nuanced understanding of the content, which is crucial for various applications.</p>
</section>
</section>
<section id="the-process-of-extraction" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="the-process-of-extraction"><span class="header-section-number">3</span> The Process of Extraction</h2>
<section id="distinguishing-extraction-from-tagging" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="distinguishing-extraction-from-tagging"><span class="header-section-number">3.1</span> Distinguishing Extraction from Tagging</h3>
<p>Extraction differs from tagging as it involves identifying and retrieving specific entities from text. Unlike tagging, where a single structured output is generated, extraction yields a list of elements, such as the names of mentioned academic papers in an article.</p>
<p><img src="https://github.com/pranath/blog/raw/master/images/tag-extract-2.png" width="800"></p>
</section>
<section id="implementing-extraction-in-code" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="implementing-extraction-in-code"><span class="header-section-number">3.2</span> Implementing Extraction in Code</h3>
<p>We begin by importing necessary functions and classes, creating models that define the structured output we aim to extract. With these models, the OpenAI function can parse the text and return the requested entities in a structured format.</p>
<div class="cell" data-tags="[]" data-execution_count="13">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> openai</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">'ignore'</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dotenv <span class="im">import</span> load_dotenv, find_dotenv</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> load_dotenv(find_dotenv()) <span class="co"># read local .env file</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>openai.api_key <span class="op">=</span> os.environ[<span class="st">'OPENAI_API_KEY'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> List</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pydantic <span class="im">import</span> BaseModel, Field</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.utils.openai_functions <span class="im">import</span> convert_pydantic_to_openai_function</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="tagging-and-extraction-in-practice" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="tagging-and-extraction-in-practice"><span class="header-section-number">4</span> Tagging and Extraction in Practice</h2>
<section id="creating-a-tagging-model" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="creating-a-tagging-model"><span class="header-section-number">4.1</span> Creating a Tagging Model</h3>
<p>Let’s develop a tagging model using PyDantic. We define a schema instructing the model to tag sentiments and languages, outlining possible values for each tag. This schema guides the language model to understand and shape the data we’re extracting.</p>
<p>So we’ll call the class tagging. We’ll have a description that says tag the piece of text, which is your information, and then a list of the text that we have to utilise that we want to tag the text to. So, first, sentiment, and then a description of the sentiment. It has to be called pos, neg, or neutral. So we’re defining values for the sentiment field, and remember, we’re fitting past in the language model. So this is how we inform the language model what shape the data we’re retrieving should have. We then have a language tag in here to get into the language.</p>
<p>So we’ll start with a description of the sentiment field. Because we know we’ll always do tagging, we’re attempting to force it to always do this tagging function. We can then establish a tagging chain by combining the prompt with this model and calling it…</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Tagging(BaseModel):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Tag the piece of text with particular info."""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    sentiment: <span class="bu">str</span> <span class="op">=</span> Field(description<span class="op">=</span><span class="st">"sentiment of text, should be `pos`, `neg`, or `neutral`"</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    language: <span class="bu">str</span> <span class="op">=</span> Field(description<span class="op">=</span><span class="st">"language of text (should be ISO 639-1 code)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>convert_pydantic_to_openai_function(Tagging)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>{'name': 'Tagging',
 'description': 'Tag the piece of text with particular info.',
 'parameters': {'title': 'Tagging',
  'description': 'Tag the piece of text with particular info.',
  'type': 'object',
  'properties': {'sentiment': {'title': 'Sentiment',
    'description': 'sentiment of text, should be `pos`, `neg`, or `neutral`',
    'type': 'string'},
   'language': {'title': 'Language',
    'description': 'language of text (should be ISO 639-1 code)',
    'type': 'string'}},
  'required': ['sentiment', 'language']}}</code></pre>
</div>
</div>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.prompts <span class="im">import</span> ChatPromptTemplate</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.chat_models <span class="im">import</span> ChatOpenAI</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> ChatOpenAI(temperature<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>tagging_functions <span class="op">=</span> [convert_pydantic_to_openai_function(Tagging)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>prompt <span class="op">=</span> ChatPromptTemplate.from_messages([</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"system"</span>, <span class="st">"Think carefully, and then tag the text as instructed"</span>),</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"user"</span>, <span class="st">"</span><span class="sc">{input}</span><span class="st">"</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>model_with_functions <span class="op">=</span> model.bind(</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    functions<span class="op">=</span>tagging_functions,</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    function_call<span class="op">=</span>{<span class="st">"name"</span>: <span class="st">"Tagging"</span>}</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>tagging_chain <span class="op">=</span> prompt <span class="op">|</span> model_with_functions</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>tagging_chain.invoke({<span class="st">"input"</span>: <span class="st">"I love langchain"</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>AIMessage(content='', additional_kwargs={'function_call': {'name': 'Tagging', 'arguments': '{\n  "sentiment": "pos",\n  "language": "en"\n}'}})</code></pre>
</div>
</div>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>tagging_chain.invoke({<span class="st">"input"</span>: <span class="st">"non mi piace questo cibo"</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>AIMessage(content='', additional_kwargs={'function_call': {'name': 'Tagging', 'arguments': '{\n  "sentiment": "neg",\n  "language": "it"\n}'}})</code></pre>
</div>
</div>
<p>And we may refer to this as a piece of text and obtain that response. So we’re running the tagging function, and we can see that the prompt and call are present, as well as the arguments that are sent in, and we can see that the sentiment is positive and the language is English. This is something we can do with another piece of text. We can change it up frequently by using a different language and a different sentiment.</p>
</section>
</section>
<section id="improving-output-with-helper-parsers" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="improving-output-with-helper-parsers"><span class="header-section-number">5</span> Improving Output with Helper Parsers</h2>
<p>And we know we’ll always be extracting the structure, so what we actually want to do is add an output parser that takes in this AI message, parses the output JSON, and simply states that, because it’s the only interesting thing here. We already know we’re going to call this method, so the fact that content is null is irrelevant to us. We’re not interested in the fact that there’s a function called this. We’re making it do it. The fact that it is calling the tagging function is likewise uninteresting to us, because we know it will call this tagging function if we compel it to.</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.output_parsers.openai_functions <span class="im">import</span> JsonOutputFunctionsParser</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>tagging_chain <span class="op">=</span> prompt <span class="op">|</span> model_with_functions <span class="op">|</span> JsonOutputFunctionsParser()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>tagging_chain.invoke({<span class="st">"input"</span>: <span class="st">"non mi piace questo cibo"</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre><code>{'sentiment': 'neg', 'language': 'it'}</code></pre>
</div>
</div>
<section id="extracting-information" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="extracting-information"><span class="header-section-number">5.1</span> Extracting Information</h3>
<p>Moving on to extraction, we define another model to capture multiple pieces of information, such as names and ages from a text. We then instruct the language model to parse these elements into a list of structured objects.</p>
<p>Extraction is similar to tagging in that it extracts many pieces of information. We’ll start by defining the bits of information we want to extract, and this is a person’s theme, so we’ll have information about a person, the name, which is a person’s name, and the age. We’ll go ahead and mark it as an optional integer. We want to extract a list of these objects, therefore we’ll construct another class called information that contains only the information that we want to extract. We’ll add a persons attribute, and this will be a list of the person’s type.</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Optional</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Person(BaseModel):</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Information about a person."""</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span> <span class="op">=</span> Field(description<span class="op">=</span><span class="st">"person's name"</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    age: Optional[<span class="bu">int</span>] <span class="op">=</span> Field(description<span class="op">=</span><span class="st">"person's age"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Information(BaseModel):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Information to extract."""</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    people: List[Person] <span class="op">=</span> Field(description<span class="op">=</span><span class="st">"List of info about people"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>So we can convert that class to OpenAI functions here, and we can see that we have information, properties, the main property is people, and then we can see that we now have the person’s description here if we look at the description of people. So, if we just convert the entity to the OpenAI function method, we take care of resolving any mentions and putting all of the essential information from the JavaScript zone block. So now we’ll set up an extraction chain.</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>convert_pydantic_to_openai_function(Information)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<pre><code>{'name': 'Information',
 'description': 'Information to extract.',
 'parameters': {'title': 'Information',
  'description': 'Information to extract.',
  'type': 'object',
  'properties': {'people': {'title': 'People',
    'description': 'List of info about people',
    'type': 'array',
    'items': {'title': 'Person',
     'description': 'Information about a person.',
     'type': 'object',
     'properties': {'name': {'title': 'Name',
       'description': "person's name",
       'type': 'string'},
      'age': {'title': 'Age',
       'description': "person's age",
       'type': 'integer'}},
     'required': ['name']}}},
  'required': ['people']}}</code></pre>
</div>
</div>
<p>First, let’s define some extraction functions. On this information block, we’ll call convert_pydantic_to_openai_function to the information function. The extraction model will be built up next. So we’ll bind functions equal to extraction functions because we want to use them, and then we’ll bind function call with the name, so that equals information since the name of the function we want the model to call is information.</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>extraction_functions <span class="op">=</span> [convert_pydantic_to_openai_function(Information)]</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>extraction_model <span class="op">=</span> model.bind(functions<span class="op">=</span>extraction_functions, function_call<span class="op">=</span>{<span class="st">"name"</span>: <span class="st">"Information"</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>extraction_model.invoke(<span class="st">"Joe is 30, his mom is Martha"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="32">
<pre><code>AIMessage(content='', additional_kwargs={'function_call': {'name': 'Information', 'arguments': '{\n  "people": [\n    {\n      "name": "Joe",\n      "age": 30\n    },\n    {\n      "name": "Martha",\n      "age": 0\n    }\n  ]\n}'}})</code></pre>
</div>
</div>
<p>So let’s put it to the test with a simple statement. We can see that it extracts the name Joe and his age of 30. This time, we receive the second person, Martha. It is zero.</p>
<p>So we’ve obviously indicated Martha being here, and the model appears to believe that if it doesn’t know the individual, it will simply put zero, which is definitely a way we can improve. We can compel the model to respond more intelligently. So what we’re going to do is add a prompt that will instruct the language model to accomplish that. So we’re adding a prompt now, and we’ve got a system that just says “extract the relevant information.” Do not get that extract partial information if it is not expressly provided.</p>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>prompt <span class="op">=</span> ChatPromptTemplate.from_messages([</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"system"</span>, <span class="st">"Extract the relevant information, if not explicitly provided do not guess. Extract partial info"</span>),</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"human"</span>, <span class="st">"</span><span class="sc">{input}</span><span class="st">"</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>extraction_chain <span class="op">=</span> prompt <span class="op">|</span> extraction_model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>extraction_chain.invoke({<span class="st">"input"</span>: <span class="st">"Joe is 30, his mom is Martha"</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre><code>AIMessage(content='', additional_kwargs={'function_call': {'name': 'Information', 'arguments': '{\n  "people": [\n    {\n      "name": "Joe",\n      "age": 30\n    },\n    {\n      "name": "Martha"\n    }\n  ]\n}'}})</code></pre>
</div>
</div>
<p>So, hopefully, it will either compel the language model or allow the language model to not always answer with the name. It will not make up the value zero for age. As a result, we are free to extract. This prompt is followed by the extraction model. And if we call this extraction chain the same thing, we can see that in the argument we have, name, Martha, and there’s nothing else to do about age, it’s correctly thinking that it doesn’t need to provide information on our age. Again, we’re probably capable of doing better than this AI message.</p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>extraction_chain <span class="op">=</span> prompt <span class="op">|</span> extraction_model <span class="op">|</span> JsonOutputFunctionsParser()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>extraction_chain.invoke({<span class="st">"input"</span>: <span class="st">"Joe is 30, his mom is Martha"</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<pre><code>{'people': [{'name': 'Joe', 'age': 30}, {'name': 'Martha'}]}</code></pre>
</div>
</div>
</section>
<section id="streamlining-the-extraction-process" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="streamlining-the-extraction-process"><span class="header-section-number">5.2</span> Streamlining the Extraction Process</h3>
<p>By employing a JSON key output function parser, we can extract specific data points without extraneous information. This refined output is not only cleaner but also more functional for subsequent data handling.</p>
<p>And so, in this case, all we actually want is the value of the arguments, which is a JSON block, and it’s quite convenient to have those parses with JSON because it’s JSON in this JSON block. We want to be able to use the various elements individually. As a result, LangChain includes a handy small output parser that can assist with this. It’s named JSONOutputFunctionsParser, and we’ll import it from the OpenAI functions of LangChainOutputParser. Then we create our tagging chain, which we can do as a prompt, and we can connect it with the function model, and we’ll now add this output parser into the final element.</p>
<p>We can try to structure it by parsing it. So let’s bring back the JSON assistance parser from previously. We can see that it’s processed into this dictionary containing persons and then a list of names, as we call it again. However, there is some unnecessary information here that we don’t actually need for extraction. We don’t really care about this list of people since, as we defined it, information is merely a vehicle that allows us to extract many components from this person. What we truly care about is this list of individuals.</p>
<p>For that, we can utilise a different assistance parser. We can use the function parser to import JSON keys. And what this will essentially do is look for a specific key, and the output will just contain that key. So we’ve slightly altered our extraction chain. We pass in our new helper parser, along with a key name and individuals to specify the field we wish to extract. Now, if we call it that, I’ll rename it. As you can see, we now only have the list. So, while it’s a tiny enhancement, it will make it easier to use downstream if extraction is indeed what we’re after for this purpose.</p>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.output_parsers.openai_functions <span class="im">import</span> JsonKeyOutputFunctionsParser</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>extraction_chain <span class="op">=</span> prompt <span class="op">|</span> extraction_model <span class="op">|</span> JsonKeyOutputFunctionsParser(key_name<span class="op">=</span><span class="st">"people"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>extraction_chain.invoke({<span class="st">"input"</span>: <span class="st">"Joe is 30, his mom is Martha"</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="40">
<pre><code>[{'name': 'Joe', 'age': 30}, {'name': 'Martha'}]</code></pre>
</div>
</div>
</section>
</section>
<section id="applying-tagging-and-extraction-to-real-world-data" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="applying-tagging-and-extraction-to-real-world-data"><span class="header-section-number">6</span> Applying Tagging and Extraction to Real-World Data</h2>
<section id="loading-and-analyzing-an-article" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="loading-and-analyzing-an-article"><span class="header-section-number">6.1</span> Loading and Analyzing an Article</h3>
<p>We will demonstrate the application of our tagging and extraction models on an actual article, showcasing how to load the document, create the models, and execute the functions to retrieve structured data.</p>
<p>So, first, we’ll fill a load with a real article from the Internet. So we’re going to employ a web-based loader from the Langchain document loaders, which we discussed in a <a href="../posts/2023-06-04-question-answering-over-documents-with-langchain.html">previous article</a>. So we’ll enter this URL here, which leads to a fantastic blog post about autonomous agents. This is going to be called with load, and it will load a few documents.</p>
<p>Because it will only load one document, we will create a single document object to represent it. Then, because this is a lengthy document, we’re not going to print it all. So the first thing we’re going to do is get the first 10,000 characters with this. If we publish the first few paragraphs of this page’s content, we won’t be able to print the entire thing because it’s quite long. However, if we print the introduction, we can see that it is an article about empowering autonomous agents.</p>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.document_loaders <span class="im">import</span> WebBaseLoader</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>loader <span class="op">=</span> WebBaseLoader(<span class="st">"https://lilianweng.github.io/posts/2023-06-23-agent/"</span>)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>documents <span class="op">=</span> loader.load()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>doc <span class="op">=</span> documents[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>page_content <span class="op">=</span> doc.page_content[:<span class="dv">10000</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-scrolled="true" data-execution_count="44">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(page_content[:<span class="dv">1000</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>





LLM Powered Autonomous Agents | Lil'Log







































Lil'Log






















Posts




Archive




Search




Tags




FAQ




emojisearch.app









      LLM Powered Autonomous Agents
    
Date: June 23, 2023  |  Estimated Reading Time: 31 min  |  Author: Lilian Weng


 


Table of Contents



Agent System Overview

Component One: Planning

Task Decomposition

Self-Reflection


Component Two: Memory

Types of Memory

Maximum Inner Product Search (MIPS)


Component Three: Tool Use

Case Studies

Scientific Discovery Agent

Generative Agents Simulation

Proof-of-Concept Examples


Challenges

Citation

References





Building agents with LLM (large language model) as its core controller is a cool concept. Several proof-of-concepts demos, such as AutoGPT, GPT-Engineer and BabyAGI, serve as inspiring examples. The potentiality of LLM extends beyond generating well-written copies, stories, essays and programs; it can be framed as a powerful general</code></pre>
</div>
</div>
</section>
<section id="extracting-information-from-large-texts" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="extracting-information-from-large-texts"><span class="header-section-number">6.2</span> Extracting Information from Large Texts</h3>
<p>For longer documents, we introduce text splitting to manage the size limitation of the language model. By dividing the text into smaller sections, we can apply our extraction model sequentially and then collate the results for a comprehensive output.</p>
<p>First, we’ll make a class that describes what we wish to tag. So we’d like to get a high-level overview of this post. So we’d like to get a synopsis, the language utilised, and any keywords. So we’re going to build this great model to describe everything. Then we’ll start a chain reaction. So we’ll build the overview tagging function. Using this approach, you can transform one base model to an overview base model and then to an open-end function. We’ll then develop our tagging model. So we’ll identify the function we built before and compel it to call this overview.</p>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Overview(BaseModel):</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Overview of a section of text."""</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    summary: <span class="bu">str</span> <span class="op">=</span> Field(description<span class="op">=</span><span class="st">"Provide a concise summary of the content."</span>)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    language: <span class="bu">str</span> <span class="op">=</span> Field(description<span class="op">=</span><span class="st">"Provide the language that the content is written in."</span>)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    keywords: <span class="bu">str</span> <span class="op">=</span> Field(description<span class="op">=</span><span class="st">"Provide keywords related to the content."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>After that, we’ll make a tagging chain. So we’re doing a prompt, which is the prompt from earlier. A query about tagging a model to a neighbouring output function.</p>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>overview_tagging_function <span class="op">=</span> [</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    convert_pydantic_to_openai_function(Overview)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>tagging_model <span class="op">=</span> model.bind(</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    functions<span class="op">=</span>overview_tagging_function,</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    function_call<span class="op">=</span>{<span class="st">"name"</span>:<span class="st">"Overview"</span>}</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>tagging_chain <span class="op">=</span> prompt <span class="op">|</span> tagging_model <span class="op">|</span> JsonOutputFunctionsParser()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>tagging_chain.invoke({<span class="st">"input"</span>: page_content})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="47">
<pre><code>{'summary': 'This article discusses the concept of building autonomous agents powered by LLM (large language model) as their core controller. It explores the key components of such agent systems, including planning, memory, and tool use. It also covers various techniques for task decomposition and self-reflection in autonomous agents. The article provides examples of case studies and challenges in implementing LLM-powered agents.',
 'language': 'English',
 'keywords': 'LLM, autonomous agents, planning, memory, tool use, task decomposition, self-reflection, case studies, challenges'}</code></pre>
</div>
</div>
<p>Now we’ll try to extract all of the papers referenced in this article. This piece is quite nice and highly intellectual, therefore it mentions a lot of papers, and we’re very curious about what those papers are. So we’ll start with some basic models. First, we want to know the title of the article, followed by the author, as we have done in the past. And then we’ll post this here. And by another class called information, and we’ll have papers, the elicited paper, so we can get a lot of things down.</p>
<div class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Paper(BaseModel):</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Information about papers mentioned."""</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    title: <span class="bu">str</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    author: Optional[<span class="bu">str</span>]</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Info(BaseModel):</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Information to extract"""</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    papers: List[Paper]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then we’ll set up our extraction chain. So we’re generating the functions that we’ll pass in, which is basically information. We then bind that to the functions parameter, or we bind function call, and instead of designating it to the info, we force it to call this info function. Then we’ll insert our chain, the extraction model, into this JSON for the function parser, which we’ll have to rename to paper. So we’re going to make it and then run it on the page content again.</p>
<div class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>paper_extraction_function <span class="op">=</span> [</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    convert_pydantic_to_openai_function(Info)</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>extraction_model <span class="op">=</span> model.bind(</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    functions<span class="op">=</span>paper_extraction_function, </span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    function_call<span class="op">=</span>{<span class="st">"name"</span>:<span class="st">"Info"</span>}</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>extraction_chain <span class="op">=</span> prompt <span class="op">|</span> extraction_model <span class="op">|</span> JsonKeyOutputFunctionsParser(key_name<span class="op">=</span><span class="st">"papers"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>extraction_chain.invoke({<span class="st">"input"</span>: page_content})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="50">
<pre><code>[{'title': 'LLM Powered Autonomous Agents', 'author': 'Lilian Weng'}]</code></pre>
</div>
</div>
<p>So far, we’ve just gotten one result: title, author, and the only one. And so this is a little perplexing, because this is both the title of the article and the author of the piece that we’re passing in. It is the article itself that is mentioned, not the papers mentioned inside it.</p>
<p>And so the language model is probably going to get confused, because if you remember the initial page, there’s a lot of, this is the article title, this is the author, and we haven’t really instructed the language model too clearly that it should be extracting the papers that are mentioned within, rather than the information about the article itself. So, in order to correct this, we’re going to give it a little improved system message.</p>
<p>So we’ll say it more explicitly, an article we’ve passed snippets from all studies cited in this article. Do not remove any of the articles. If no papers are listed, that’s alright; if you’re turning the empty list, you don’t need to remove it. You are not required to invent anything. Any additional information only extracts what you require. As a result, we’re going to expand this prompt such that it’s much more descriptive of how the language model should act. We’ll utilise this prompt in our new chain; everything else is the same, so it’s the same extraction model and output parser.</p>
<p>And then we’ll call this new chain on that page content, and we’ll get back a list of articles with titles and authors, which will function much better.</p>
<div class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>template <span class="op">=</span> <span class="st">"""A article will be passed to you. Extract from it all papers that are mentioned by this article. </span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="st">Do not extract the name of the article itself. If no papers are mentioned that's fine - you don't need to extract any! Just return an empty list.</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="st">Do not make up or guess ANY extra information. Only extract what exactly is in the text."""</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>prompt <span class="op">=</span> ChatPromptTemplate.from_messages([</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"system"</span>, template),</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    (<span class="st">"human"</span>, <span class="st">"</span><span class="sc">{input}</span><span class="st">"</span>)</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>extraction_chain <span class="op">=</span> prompt <span class="op">|</span> extraction_model <span class="op">|</span> JsonKeyOutputFunctionsParser(key_name<span class="op">=</span><span class="st">"papers"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>extraction_chain.invoke({<span class="st">"input"</span>: page_content})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="53">
<pre><code>[{'title': 'Chain of thought (CoT; Wei et al. 2022)', 'author': 'Wei et al.'},
 {'title': 'Tree of Thoughts (Yao et al. 2023)', 'author': 'Yao et al.'},
 {'title': 'LLM+P (Liu et al. 2023)', 'author': 'Liu et al.'},
 {'title': 'ReAct (Yao et al. 2023)', 'author': 'Yao et al.'},
 {'title': 'Reflexion (Shinn &amp; Labash 2023)', 'author': 'Shinn &amp; Labash'},
 {'title': 'Chain of Hindsight (CoH; Liu et al. 2023)',
  'author': 'Liu et al.'},
 {'title': 'Algorithm Distillation (AD; Laskin et al. 2023)',
  'author': 'Laskin et al.'}]</code></pre>
</div>
</div>
<p>As a result, these are all excellent papers in this field that are not the article itself, but rather the author’s attempt to convey a point. We can also do some sanity checks to ensure that it’s operating well, so we can pass in a simple message like, hello, we anticipate this to be a list and indeed it is, and so here are instructions for just returning empty lists if no papers are specified, that they’re working properly.</p>
<div class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>extraction_chain.invoke({<span class="st">"input"</span>: <span class="st">"hi"</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="54">
<pre><code>[]</code></pre>
</div>
</div>
<p>So it appears to be making a good pass here. But keep in mind that this is only the first ten-five new characters in the article. What if we want to do it on the entire article and reach all of the publications that are cited in it? To do this, we’ll employ yet another notion, this time text splitting. So using a text splitter, and we’ll use the first character text splitter, which we studied in the previous post.</p>
<p>The thing we need to do is text split because this article is extremely long, and we try to pass that article if it’s language model straight because it will be too large for the token limit of the model. So we’re going to separate it into smaller parts of text, give those pieces of text to the language model individually, and then integrate all the results at the end.</p>
<div class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.text_splitter <span class="im">import</span> RecursiveCharacterTextSplitter</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>text_splitter <span class="op">=</span> RecursiveCharacterTextSplitter(chunk_overlap<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>So let’s make some divides by calling split text on the document’s page content, and when we look at how many splits we have, we see that we have 14 separate splits. So what we’re going to try now is to establish a whole chain with link-in expression language. We’ll start with the page content and divide it into parts. We’ll then pass all of those individual splits to the extraction chain we described earlier, and then we’ll merge all of the results together.</p>
<div class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>splits <span class="op">=</span> text_splitter.split_text(doc.page_content)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(splits)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="57">
<pre><code>14</code></pre>
</div>
</div>
<p>So, one thing we’ll undoubtedly need to do is write a function that can concatinate lists of lists. So we’re going to write this flatten function, which simply takes in a list of lists and flattens it. This is useful because we’ll be extracting a list of papers mentioned for each division and then combining them together.</p>
<div class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> flatten(matrix):</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    flat_list <span class="op">=</span> []</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> row <span class="kw">in</span> matrix:</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>        flat_list <span class="op">+=</span> row</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flat_list</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>flatten([[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="59">
<pre><code>[1, 2, 3, 4]</code></pre>
</div>
</div>
<div class="cell" data-scrolled="true" data-execution_count="60">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(splits[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>LLM Powered Autonomous Agents | Lil'Log







































Lil'Log






















Posts




Archive




Search




Tags




FAQ




emojisearch.app









      LLM Powered Autonomous Agents
    
Date: June 23, 2023  |  Estimated Reading Time: 31 min  |  Author: Lilian Weng


 


Table of Contents



Agent System Overview

Component One: Planning

Task Decomposition

Self-Reflection


Component Two: Memory

Types of Memory

Maximum Inner Product Search (MIPS)


Component Three: Tool Use

Case Studies

Scientific Discovery Agent

Generative Agents Simulation

Proof-of-Concept Examples


Challenges

Citation

References





Building agents with LLM (large language model) as its core controller is a cool concept. Several proof-of-concepts demos, such as AutoGPT, GPT-Engineer and BabyAGI, serve as inspiring examples. The potentiality of LLM extends beyond generating well-written copies, stories, essays and programs; it can be framed as a powerful general problem solver.
Agent System Overview#
In a LLM-powered autonomous agent system, LLM functions as the agent’s brain, complemented by several key components:

Planning

Subgoal and decomposition: The agent breaks down large tasks into smaller, manageable subgoals, enabling efficient handling of complex tasks.
Reflection and refinement: The agent can do self-criticism and self-reflection over past actions, learn from mistakes and refine them for future steps, thereby improving the quality of final results.


Memory

Short-term memory: I would consider all the in-context learning (See Prompt Engineering) as utilizing short-term memory of the model to learn.
Long-term memory: This provides the agent with the capability to retain and recall (infinite) information over extended periods, often by leveraging an external vector store and fast retrieval.


Tool use

The agent learns to call external APIs for extra information that is missing from the model weights (often hard to change after pre-training), including current information, code execution capability, access to proprietary information sources and more.</code></pre>
</div>
</div>
<p>Another thing we’ll need to do is have a technique for preparing the splits that you pass into the chain. So keep in mind that the chain fits in an input variable, namely a dictionary with an input key. If we look at the first split in this list, it’s just text. So we’ll need a method to turn this collection of text into a list of dictionaries where that text is now the input key. We’ll accomplish this by declaring a function for it, because this will be the initial function in the chain.</p>
<p>We’ll encase it in a runnable lambda. So a runnable lambda is simply a langchain wrapper that accepts a function or a lambda and converts it to this runnable object. When you have functions that are the first member of the chain, you must perform this so that it can be correctly written together. So we’ll define this preprocessing function right here. So we’re building a runnable that takes an input and wants to pass the document as a rally and the page function as a document.</p>
<div class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.schema.runnable <span class="im">import</span> RunnableLambda</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>prep <span class="op">=</span> RunnableLambda(</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> x: [{<span class="st">"input"</span>: doc} <span class="cf">for</span> doc <span class="kw">in</span> text_splitter.split_text(x)]</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>So the x in this case will be a string. And what we’re doing is writing a function that takes a string, splits it, and then creates a list of dictionaries, each of which is an input matching to the split. We can call it on a string and receive back a list of dictionaries if we play around with it and see what it does. Because the text splitter does not break it up, there is only one dictionary here. These x’s are really short. So it’s just taking this text, dividing it, and making a list of dictionaries.</p>
<div class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>prep.invoke(<span class="st">"hi"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="63">
<pre><code>[{'input': 'hi'}]</code></pre>
</div>
</div>
<p>And the reason this isn’t required is that this will be the input, so the following portion, the extraction chain, so we want to make a number of inputs there. So now we can start making our chain. So we’ll have this preparation function. We’d like to then transmit this along to the extraction chain. Remember that the extraction chain operates on a single element, and we have a list of items to pass in here. So, on the extraction chain, we can refer to it as a dot map.</p>
<div class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>chain <span class="op">=</span> prep <span class="op">|</span> extraction_chain.<span class="bu">map</span>() <span class="op">|</span> flatten</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And this basically means to take the previous input, which is a list of elements in this case, and map this chain over them. So, once again, this extraction chain will return to the list as we specify it, resulting in a list of lists. As a result, we’re going to call it flatten. And in this case, the usual function that we defined earlier can be used. Because it isn’t the first in the series, we don’t need to encapsulate it in a runable lambda. We could if we wanted to, but we don’t have to.</p>
<p>So we have this chain, and if we call chain.invoke, it will go through the entire page, content, and document. We can see that it will take some time, but it will eventually return with the answer. So it does two things: first, it limits it to 14 pieces, and then it passes that to the extraction chain. When it passes it to the extraction chain, it automatically parallelizes many of those calls. It parallelizes by default by five calls.</p>
<div class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>chain.invoke(doc.page_content)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="66">
<pre><code>[{'title': 'AutoGPT', 'author': ''},
 {'title': 'GPT-Engineer', 'author': ''},
 {'title': 'BabyAGI', 'author': ''},
 {'title': 'Chain of thought (CoT; Wei et al. 2022)', 'author': ''},
 {'title': 'Tree of Thoughts (Yao et al. 2023)', 'author': ''},
 {'title': 'LLM+P (Liu et al. 2023)', 'author': ''},
 {'title': 'ReAct (Yao et al. 2023)', 'author': ''},
 {'title': 'Reflexion (Shinn &amp; Labash 2023)', 'author': ''},
 {'title': 'Reflexion framework', 'author': 'Shinn &amp; Labash'},
 {'title': 'Chain of Hindsight', 'author': 'Liu et al.'},
 {'title': 'Algorithm Distillation', 'author': 'Laskin et al.'},
 {'title': 'Algorithm Distillation', 'author': 'Laskin et al. 2023'},
 {'title': 'ED (expert distillation)', 'author': ''},
 {'title': 'RL^2', 'author': 'Duan et al. 2017'},
 {'title': 'LSH: Locality-Sensitive Hashing', 'author': ''},
 {'title': 'ANNOY: Approximate Nearest Neighbors Oh Yeah', 'author': ''},
 {'title': 'HNSW: Hierarchical Navigable Small World', 'author': ''},
 {'title': 'FAISS: Facebook AI Similarity Search', 'author': ''},
 {'title': 'ScaNN: Scalable Nearest Neighbors', 'author': ''},
 {'title': 'MRKL: Modular Reasoning, Knowledge and Language',
  'author': 'Karpas et al. 2022'},
 {'title': 'TALM: Tool Augmented Language Models',
  'author': 'Parisi et al. 2022'},
 {'title': 'Toolformer', 'author': 'Schick et al. 2023'},
 {'title': 'HuggingGPT', 'author': 'Shen et al. 2023'},
 {'title': 'API-Bank: A Benchmark for Evaluating Tool-Augmented Language Models',
  'author': 'Li et al. 2023'},
 {'title': 'ChemCrow: Augmenting Language Models with Expert-Designed Tools for Scientific Discovery',
  'author': 'Bran et al. 2023'},
 {'title': 'Boiko et al. (2023)', 'author': 'Boiko et al.'},
 {'title': 'Generative Agents Simulation', 'author': 'Park, et al. 2023'},
 {'title': 'Park et al. 2023', 'author': ''},
 {'title': 'Super Mario: How Nintendo Conquered America',
  'author': 'Jeff Ryan'},
 {'title': 'Model-View-Controller (MVC) Explained', 'author': 'Techopedia'},
 {'title': 'Python Game Development: Creating a Snake Game',
  'author': 'Real Python'},
 {'title': 'Paper A', 'author': 'Author A'},
 {'title': 'Paper B', 'author': 'Author B'},
 {'title': 'Paper C', 'author': 'Author C'},
 {'title': 'Chain of thought prompting elicits reasoning in large language models.',
  'author': 'Wei et al.'},
 {'title': 'Tree of Thoughts: Deliberate Problem Solving with Large Language Models.',
  'author': 'Yao et al.'},
 {'title': 'Chain of Hindsight Aligns Language Models with Feedback',
  'author': 'Liu et al.'},
 {'title': 'LLM+P: Empowering Large Language Models with Optimal Planning Proficiency',
  'author': 'Liu et al.'},
 {'title': 'ReAct: Synergizing reasoning and acting in language models.',
  'author': 'Yao et al.'},
 {'title': 'Reflexion: an autonomous agent with dynamic memory and self-reflection',
  'author': 'Shinn &amp; Labash'},
 {'title': 'In-context Reinforcement Learning with Algorithm Distillation',
  'author': 'Laskin et al.'},
 {'title': 'MRKL Systems A modular, neuro-symbolic architecture that combines large language models, external knowledge sources and discrete reasoning.',
  'author': 'Karpas et al.'},
 {'title': 'API-Bank: A Benchmark for Tool-Augmented LLMs',
  'author': 'Li et al.'},
 {'title': 'HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in HuggingFace',
  'author': 'Shen et al.'},
 {'title': 'ChemCrow: Augmenting large-language models with chemistry tools.',
  'author': 'Bran et al.'},
 {'title': 'Emergent autonomous scientific research capabilities of large language models.',
  'author': 'Boiko et al.'},
 {'title': 'Generative Agents: Interactive Simulacra of Human Behavior.',
  'author': 'Joon Sung Park, et al.'}]</code></pre>
</div>
</div>
<p>So it isn’t completely parallelizing, but it is speeding up the sequence in and out. When all of those calls have been completed, it will be handed to the final flatten function. And there we have it. It returns a list of extracted papers, so step the title and step the author. It had been skimmed through. For some of them, we can see that it leaves the author empty.</p>
<p>If you look at these references you will see we have document A and author A. This looks to be incorrect, but if you look at the article that this is referencing, you will see that it gives itself article as examples in code in that artical, in which it includes, among other things, extraction and retrieval of the generation. So there’s a lot of language in there that’s emulating some false papers and getting a response like this. As a result, they’re picking it up appropriately.</p>
</section>
</section>
<section id="conclusion-the-power-of-structured-data-extraction" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="conclusion-the-power-of-structured-data-extraction"><span class="header-section-number">7</span> Conclusion: The Power of Structured Data Extraction</h2>
<p>Tagging and extraction are powerful methods for turning unstructured text into structured data, opening up numerous possibilities for data analysis and insight generation. By understanding and applying these techniques through OpenAI’s functions and Langchain, developers can efficiently address common use cases and unlock the full potential of language models for data structuring tasks.</p>
</section>
<section id="acknowledgements" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="acknowledgements"><span class="header-section-number">8</span> Acknowledgements</h2>
<p>I’d like to express my thanks to the wonderful <a href="https://www.deeplearning.ai/short-courses/functions-tools-agents-langchain/">Functions, Tools and Agents with LangChain</a> by DeepLearning.ai - which i completed, and acknowledge the use of some images and other materials from the course in this article.</p>


</section>

<link href="//cdn-images.mailchimp.com/embedcode/classic-071822.css" rel="stylesheet" type="text/css"><div id="mc_embed_signup">
    <form action="https://livingdatalab.us8.list-manage.com/subscribe/post?u=e2d57b0d6e43b4f6bff927a55&amp;id=a30bdff125&amp;f_id=009d05e0f0" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
        <div id="mc_embed_signup_scroll">
        <h2 class="anchored">Subscribe</h2>
<div class="mc-field-group">
    <label for="mce-EMAIL">Email Address
</label>
    <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" required="">
    <span id="mce-EMAIL-HELPERTEXT" class="helper_text"></span>
</div>
    <div id="mce-responses" class="clear foot">
        <div class="response" id="mce-error-response" style="display:none"></div>
        <div class="response" id="mce-success-response" style="display:none"></div>
    </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_e2d57b0d6e43b4f6bff927a55_a30bdff125" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot">
                <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button">
            </div>
        </div>
    </div>
</form>
</div><script type="text/javascript">(function($) {window.fnames = new Array(); window.ftypes = new Array();fnames[0]='EMAIL';ftypes[0]='email';fnames[1]='FNAME';ftypes[1]='text';fnames[2]='LNAME';ftypes[2]='text';fnames[3]='ADDRESS';ftypes[3]='address';fnames[4]='PHONE';ftypes[4]='phone';fnames[5]='BIRTHDAY';ftypes[5]='birthday';}(jQuery));var $mcj = jQuery.noConflict(true);</script></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp("http:\/\/livingdatalab\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">LivingDataLab AI Technical Blog</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



</body></html>